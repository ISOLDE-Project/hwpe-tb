// Copyleft
// snitch cluster wrapper axi
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51

// AUTOMATICALLY GENERATED by clustergen.py; edit the script or configuration
// instead.


//`include "axi/typedef.svh"
//`include "axi/assign.svh"

`define __AXI_TO_AW(__opt_as, __lhs, __lhs_sep, __rhs, __rhs_sep)   \
  __opt_as __lhs``__lhs_sep``id     = __rhs``__rhs_sep``id;         \
  __opt_as __lhs``__lhs_sep``addr   = __rhs``__rhs_sep``addr;       \
  __opt_as __lhs``__lhs_sep``len    = __rhs``__rhs_sep``len;        \
  __opt_as __lhs``__lhs_sep``size   = __rhs``__rhs_sep``size;       \
  __opt_as __lhs``__lhs_sep``burst  = __rhs``__rhs_sep``burst;      \
  __opt_as __lhs``__lhs_sep``lock   = __rhs``__rhs_sep``lock;       \
  __opt_as __lhs``__lhs_sep``cache  = __rhs``__rhs_sep``cache;      \
  __opt_as __lhs``__lhs_sep``prot   = __rhs``__rhs_sep``prot;       \
  //__opt_as __lhs``__lhs_sep``qos    = __rhs``__rhs_sep``qos;        \
 // __opt_as __lhs``__lhs_sep``region = __rhs``__rhs_sep``region;     \
 // __opt_as __lhs``__lhs_sep``atop   = __rhs``__rhs_sep``atop;       \
 // __opt_as __lhs``__lhs_sep``user   = __rhs``__rhs_sep``user;
`define __AXI_TO_W(__opt_as, __lhs, __lhs_sep, __rhs, __rhs_sep)    \
  __opt_as __lhs``__lhs_sep``data   = __rhs``__rhs_sep``data;       \
  __opt_as __lhs``__lhs_sep``strb   = __rhs``__rhs_sep``strb;       \
  __opt_as __lhs``__lhs_sep``last   = __rhs``__rhs_sep``last;       \
 // __opt_as __lhs``__lhs_sep``user   = __rhs``__rhs_sep``user;
`define __AXI_TO_B(__opt_as, __lhs, __lhs_sep, __rhs, __rhs_sep)    \
  __opt_as __lhs``__lhs_sep``id     = __rhs``__rhs_sep``id;         \
  __opt_as __lhs``__lhs_sep``resp   = __rhs``__rhs_sep``resp;       \
 // __opt_as __lhs``__lhs_sep``user   = __rhs``__rhs_sep``user;
`define __AXI_TO_AR(__opt_as, __lhs, __lhs_sep, __rhs, __rhs_sep)   \
  __opt_as __lhs``__lhs_sep``id     = __rhs``__rhs_sep``id;         \
  __opt_as __lhs``__lhs_sep``addr   = __rhs``__rhs_sep``addr;       \
  __opt_as __lhs``__lhs_sep``len    = __rhs``__rhs_sep``len;        \
  __opt_as __lhs``__lhs_sep``size   = __rhs``__rhs_sep``size;       \
  __opt_as __lhs``__lhs_sep``burst  = __rhs``__rhs_sep``burst;      \
  __opt_as __lhs``__lhs_sep``lock   = __rhs``__rhs_sep``lock;       \
  __opt_as __lhs``__lhs_sep``cache  = __rhs``__rhs_sep``cache;      \
 // __opt_as __lhs``__lhs_sep``prot   = __rhs``__rhs_sep``prot;       \
 // __opt_as __lhs``__lhs_sep``qos    = __rhs``__rhs_sep``qos;        \
 // __opt_as __lhs``__lhs_sep``region = __rhs``__rhs_sep``region;     \
 // __opt_as __lhs``__lhs_sep``user   = __rhs``__rhs_sep``user;
`define __AXI_TO_R(__opt_as, __lhs, __lhs_sep, __rhs, __rhs_sep)    \
  __opt_as __lhs``__lhs_sep``id     = __rhs``__rhs_sep``id;         \
  __opt_as __lhs``__lhs_sep``data   = __rhs``__rhs_sep``data;       \
  __opt_as __lhs``__lhs_sep``resp   = __rhs``__rhs_sep``resp;       \
  __opt_as __lhs``__lhs_sep``last   = __rhs``__rhs_sep``last;       \
//  __opt_as __lhs``__lhs_sep``user   = __rhs``__rhs_sep``user;



`define __RESP_TO_AXI_IF(__lhs, __rhs)                               \
  assign __lhs``.awready = __rhs``.aw_ready;                         \
  assign __lhs``.arready = __rhs``.ar_ready;                         \
  assign __lhs``.wready = __rhs``.w_ready;                           \
  assign __lhs``.bvalid = __rhs``.b_valid;                           \
  `__AXI_TO_B(assign, __lhs``.b, ,__rhs``.b,. )         \
  assign __lhs``.rvalid = __rhs``.r_valid;                            \
  `__AXI_TO_R(assign, __lhs``.r, , __rhs``.r, .)   


`define __REQ_TO_AXI_IF(__lhs, __rhs)    \
  `__AXI_TO_AW(assign,__lhs``.aw,,__rhs``.aw,. ) \
   assign __lhs``.awvalid = __rhs``.aw_valid;                         \
  `__AXI_TO_W (assign,__lhs``.w,,__rhs``.w,.  )    \
  assign __lhs``.wvalid = __rhs``.w_valid;                           \
  assign __lhs``.bready = __rhs``.b_ready;                           \
  `__AXI_TO_AR(assign,__lhs``.ar,,__rhs``.ar,. )    \
  assign __lhs``.arvalid = __rhs``.ar_valid;                         \
  assign __lhs``.rready = __rhs``.r_ready;   

// verilog_lint: waive-start package-filename
package renode_memory_pkg;


  localparam int unsigned AddrWidth = 32;
  localparam int unsigned DataWidth = 32;
  localparam int unsigned IdWidthIn = 8;
  localparam int unsigned UserWidth = 1;


  typedef logic [AddrWidth-1:0] addr_t;
  typedef logic [DataWidth-1:0] data_t;
  typedef logic [DataWidth/8-1:0] strb_t;
  typedef logic [IdWidthIn-1:0] id_t;
  typedef logic [UserWidth-1:0] user_t;



  // `AXI_TYPEDEF_ALL(mem_in, addr_t, id_t, data_t, strb_t, user_t)
  // `AXI_TYPEDEF_ALL(mem_out, addr_t, id_t, data_t, strb_t, user_t)

  // `AXI_TYPEDEF_ALL(axi_connection, addr_t, id_t, data_t, strb_t, user_t)


endpackage



module master (
    //input  logic                             clk,
    //input  logic                             areset_n,
          renode_axi_if              m_axi_if,
    input renode_pkg::bus_connection bus_controller
    //output renode_memory_pkg::mem_out_req_t  mem_out_req_o,
    //input  renode_memory_pkg::mem_out_resp_t mem_out_req_i
);

  logic gate;
  // logic i_clk;
  // assign i_clk = clk && gate;

  //renode_axi_if m_axi_if (.aclk(clk));
  //assign m_axi_if.areset_n = areset_n;

  // `__REQ_TO_AXI_IF(m_axi_if, mem_out_req_o)
  // `__RESP_TO_AXI_IF(m_axi_if, mem_out_req_i)


  renode_axi_manager m_axi_mem (
      m_axi_if,
      bus_controller
  );


  address_t address = 32'h10;
  valid_bits_e data_bits = renode_pkg::Word;
  data_t wdata = 32'h100;
  data_t rdata = 32'h101;
  ;
  bit is_error;


  always_ff @(posedge m_axi_if.aclk) begin

    repeat (8) @(posedge m_axi_if.aclk);
    bus_controller.write(address, data_bits, wdata, is_error);
    repeat (8) @(posedge m_axi_if.aclk);
    bus_controller.read(address, data_bits, rdata, is_error);
    if(wdata!=rdata) begin
      string error_msg;
      error_msg = $sformatf("Error! wdata!= rdata\n");
      $error(error_msg);
      $finish;
    end
  end

endmodule


import renode_pkg::renode_connection, renode_pkg::bus_connection;
import renode_pkg::message_t, renode_pkg::address_t, renode_pkg::data_t, renode_pkg::valid_bits_e;

module top (
    input logic clk,
    input logic reset
);


  renode_connection connection = new();
  bus_connection    bus_peripheral = new(connection);
  bus_connection    bus_controller = new(connection);
  time              renode_time = 0;

  //renode_memory_pkg::axi_connection_req_t  axi_req;
  //renode_memory_pkg::axi_connection_resp_t axi_resp;

  renode_axi_if axi_if (.aclk(clk));
  //assign axi_if.areset_n = reset;


  //logic                                    areset_n;

  renode_memory mem (
      .s_axi_if(axi_if),
      .bus_peripheral(bus_peripheral)
  );

  master ctr (
      .m_axi_if(axi_if),
      .bus_controller(bus_controller)
  );
  // Print some stuff as an example
  initial begin
    if ($test$plusargs("trace") != 0) begin
      $display("[%0t] Tracing to logs/vlt_dump.vcd...\n", $time);
      $dumpfile("logs/vlt_dump.vcd");
      $dumpvars();
    end
    axi_if.areset_n = 0;
    $display("[%0t] Model running...\n", $time);
  end

  always_ff @(posedge clk) begin
    if (!reset) begin
      bus_peripheral.reset_assert();
    end
  end

  always @(bus_peripheral.reset_assert_response) begin
    bus_controller.reset_assert();
  end

  always @(bus_controller.reset_assert_response) begin
    bus_controller.reset_deassert();
  end



endmodule
